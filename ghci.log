GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/sayuri/bprog2022/.ghci
2022-05-19 15:41:25.451960427
>>> 313 + 307
620
2022-05-19 15:54:24.120745491
>>> 3 + 2 * 5
13
2022-05-19 15:55:15.643532693
>>> (3 + 2) * 5
25
2022-05-19 15:55:36.926640964
>>> 330 / 2
165.0
2022-05-19 15:55:52.384346485
>>> 5 - 4 - 8
-7
2022-05-19 15:56:11.796251767
>>> 10 * 30
300
2022-05-19 15:56:28.030737656
>>> 1030 + 1127 * 330
372940
2022-05-19 15:56:48.765185943
>>> sqrt 2
1.4142135623730951
2022-05-19 15:59:08.089084835
>>> sqrt 5
2.23606797749979
2022-05-19 15:59:57.735969095
>>> sqrt 3
1.7320508075688772
2022-05-19 16:00:07.654442686
>>> double

<interactive>:11:1: error: Variable not in scope: double
2022-05-19 16:02:26.77091454
>>> double 3

<interactive>:12:1: error: Variable not in scope: double :: t0 -> t
2022-05-19 16:02:41.54215273
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/sayuri/bprog2022/.ghci
2022-05-26 15:02:13.036361971
>>> maxBound :: Int
9223372036854775807
2022-05-26 15:03:30.881062329
>>> 2 ^ 63 - 1
9223372036854775807
2022-05-26 15:05:02.221133265
>>> minBound :: Int
-9223372036854775808
2022-05-26 15:05:34.804100704
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
:l src/First.hs
Ok, no modules loaded.
2022-05-26 15:48:25.654824766
>>> [1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-05-26 15:48:25.813798102
>>> double 3
6
2022-05-26 15:56:14.152210566
>>> double 123
246
2022-05-26 15:56:19.916473333
>>> double 1 + 3
5
2022-05-26 15:56:35.664729898
>>> double (1 + 3)
8
2022-05-26 15:56:53.794352317
>>> double (6 + 9)
30
2022-05-26 15:57:06.939581861
>>> double (1 + 2)
6
2022-05-26 15:57:22.316727335
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/sayuri/bprog2022/.ghci
2022-06-09 14:54:57.755105538
>>> 2 + 3 * 4
14
2022-06-09 14:57:49.866120299
>>> ( 2 + 3 )* 4
20
2022-06-09 14:58:54.141509712
>>> sqrt (3 ^ 2 + 4 ^ 2)
5.0
2022-06-09 15:00:12.559388521
>>> :i sqrt
type Floating :: * -> Constraint
class Fractional a => Floating a where
  ...
  sqrt :: a -> a
  ...
  	-- Defined in ‘GHC.Float’
2022-06-09 15:00:55.21261133
>>> sqrt (3 ^ 2 + 4 ^ 2)
5.0
2022-06-09 15:03:26.728054911
>>> head [1,2,3,4,5]
1
2022-06-09 15:05:02.257633107
>>> tail[

<interactive>:7:6: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-09 15:05:18.431968511
>>> tail [1,2,3,4,5]
[2,3,4,5]
2022-06-09 15:05:36.44217523
>>> [1,2,3,4,5] !! 2
3
2022-06-09 15:06:27.813948465
>>> take 3 [1,2,3,4,5]
[1,2,3]
2022-06-09 15:06:52.330387919
>>> drop 3 [1,2,3,4,5]
[4,5]
2022-06-09 15:07:35.305450611
>>> sqrt (25 :: Int)

<interactive>:12:1: error:
    • No instance for (Floating Int) arising from a use of ‘sqrt’
    • In the expression: sqrt (25 :: Int)
      In an equation for ‘it’: it = sqrt (25 :: Int)
2022-06-09 15:08:00.770201915
>>> sqrt (25 :: double)

<interactive>:13:7: error:
    • Could not deduce (Num double) arising from the literal ‘25’
      from the context: Floating a
        bound by the inferred type of it :: Floating a => a
        at <interactive>:13:1-19
      Possible fix:
        add (Num double) to the context of
          an expression type signature:
            forall double. double
    • In the first argument of ‘sqrt’, namely ‘(25 :: double)’
      In the expression: sqrt (25 :: double)
      In an equation for ‘it’: it = sqrt (25 :: double)
2022-06-09 15:09:29.294224018
>>> sqrt (25 :: Double)
5.0
2022-06-09 15:09:59.037933334
>>> sprt 25

<interactive>:15:1: error:
    • Variable not in scope: sprt :: t0 -> t
    • Perhaps you meant ‘sqrt’ (imported from Prelude)
2022-06-09 15:10:07.580506854
>>> sprt 25

<interactive>:16:1: error:
    • Variable not in scope: sprt :: t0 -> t
    • Perhaps you meant ‘sqrt’ (imported from Prelude)
2022-06-09 15:10:22.198088527
>>> sqrt 25
5.0
2022-06-09 15:10:34.472745264
>>> length [1,2,3,4,5]
5
2022-06-09 15:11:42.143824932
>>> sun [1,2,3,4,5]

<interactive>:19:1: error:
    • Variable not in scope: sun :: [a0] -> t
    • Perhaps you meant one of these:
        ‘sum’ (imported from Prelude), ‘sin’ (imported from Prelude)
2022-06-09 15:11:56.756178619
>>> sum [1,2,3,4,5]
15
2022-06-09 15:12:11.889141602
>>> product [1,2,3,4,5]
120
2022-06-09 15:12:34.724831242
>>> [1,2,3] ++ [4,5]
[1,2,3,4,5]
2022-06-09 15:12:50.43228341
>>> reverse [1,2,3,4,5]
[5,4,3,2,1]
2022-06-09 15:13:14.67440028
>>> hoge 25 :: Int

<interactive>:24:1: error: Variable not in scope: hoge :: t0 -> Int
2022-06-09 15:13:29.517617233
>>> sum [1,2,3,4,5,6,7,8,9,10]
55
2022-06-09 15:15:09.805054602
>>> legth [1,2,3,45,6,7,8,]

<interactive>:26:23: error: parse error on input ‘]’
2022-06-09 15:15:26.125729722
>>> length [1,2,3,4,56,,7,,8,9,9]

<interactive>:27:20: error: parse error on input ‘,’
2022-06-09 15:15:44.167411147
>>> length [1,2,3,4,5,6,7]
7
2022-06-09 15:16:14.52859681
>>> take 1 [1,2,3,4,5,6]
[1]
2022-06-09 15:16:46.471344398
>>> drop 2 [1,2,3,4,5]
[3,4,5]
2022-06-09 15:17:08.344936933
>>> product [1,2,3,4,5,6,7,8]
40320
2022-06-09 15:17:32.233839367
>>> reverse [1,2,3,4,5,67,8,]

<interactive>:32:25: error: parse error on input ‘]’
2022-06-09 15:17:54.101419493
>>> sqrt [1,3,4,2,6]

<interactive>:33:1: error:
    • Non type-variable argument in the constraint: Floating [a]
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall {a}. (Floating [a], Num a) => [a]
2022-06-09 15:18:13.325958229
>>> qsort [1,4,6,2,3]

<interactive>:34:1: error:
    Variable not in scope: qsort :: [a0] -> t
2022-06-09 15:18:55.001889453
>>> qsort [1,3,2,4,5]

<interactive>:35:1: error:
    Variable not in scope: qsort :: [a0] -> t
2022-06-09 15:20:25.95510419
>>> qsort [x] = [x]
2022-06-09 15:20:42.55492086
>>> qsort [1,,3,2]

<interactive>:37:10: error: parse error on input ‘,’
2022-06-09 15:21:08.71043366
>>> qsort [x]

<interactive>:38:8: error: Variable not in scope: x
2022-06-09 15:21:36.889259157
>>> clear

<interactive>:39:1: error: Variable not in scope: clear
2022-06-09 15:21:59.336377303
>>> head [1,2,3,4,5]
1
2022-06-09 15:22:20.556203447
>>> product [5,4,3,6,8,0]
0
2022-06-09 15:22:42.572694294
>>> head[]
*** Exception: Prelude.head: empty list
2022-06-09 15:48:47.194272565
>>> head []
*** Exception: Prelude.head: empty list
2022-06-09 15:48:51.374794837
>>> head [1,2,3,4,5]
1
2022-06-09 15:49:10.281508099
>>> head [3,1,4,1,5]
3
2022-06-09 15:49:26.930234208
>>> tail [1,2,3,4,5]
[2,3,4,5]
2022-06-09 15:49:47.89598509
>>> hoge = [3,1,4,1,5] :: [Int]
2022-06-09 15:50:32.054103764
>>> hoge
[3,1,4,1,5]
2022-06-09 15:50:57.037409951
>>> head hoge
3
2022-06-09 15:51:23.656943534
>>> tail hoge
[1,4,1,5]
2022-06-09 15:51:30.59267639
>>> tail 

<interactive>:51:1: error:
    • No instance for (Show ([a0] -> [a0]))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-09 15:52:30.124957441
>>> tail []
*** Exception: Prelude.tail: empty list
2022-06-09 15:52:36.143498133
>>> hoge !! 2
4
2022-06-09 15:54:16.130080397
>>> hoge !! 0
3
2022-06-09 15:55:31.76193099
>>> hoge 2 !! hoge

<interactive>:55:1: error:
    • Couldn't match expected type: t0 -> [a]
                  with actual type: [Int]
    • The function ‘hoge’ is applied to one value argument,
        but its type ‘[Int]’ has none
      In the first argument of ‘(!!)’, namely ‘hoge 2’
      In the expression: hoge 2 !! hoge
    • Relevant bindings include it :: a (bound at <interactive>:55:1)

<interactive>:55:11: error:
    • Couldn't match expected type ‘Int’ with actual type ‘[Int]’
    • In the second argument of ‘(!!)’, namely ‘hoge’
      In the expression: hoge 2 !! hoge
      In an equation for ‘it’: it = hoge 2 !! hoge
2022-06-09 15:55:48.549416698
>>> hoge !! 2
4
2022-06-09 15:56:14.64624302
>>> take 3 hoge
[3,1,4]
2022-06-09 15:56:30.779504721
>>> drop 3 hoge
[1,5]
2022-06-09 15:56:57.585015406
>>> hoge
[3,1,4,1,5]
2022-06-09 15:57:05.956409063
>>> drop 3 hoge
[1,5]
2022-06-09 15:57:20.517820492
>>> lenght hoge

<interactive>:61:1: error:
    • Variable not in scope: lenght :: [Int] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-06-09 15:57:37.402735722
>>> length hoge
5
2022-06-09 15:57:53.558410879
>>> take 5 hoge
[3,1,4,1,5]
2022-06-09 15:58:40.614304241
>>> drop 5 hoge
[]
2022-06-09 15:58:50.234878122
>>> hoge !! 5
*** Exception: Prelude.!!: index too large
2022-06-09 15:58:58.506844661
>>> take 10 hoge
[3,1,4,1,5]
2022-06-09 15:59:08.702120362
>>> drop 10 hoge
[]
2022-06-09 16:00:19.313525658
>>> lengtn hoge

<interactive>:68:1: error:
    • Variable not in scope: lengtn :: [Int] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-06-09 16:00:58.386928984
>>> length hoge
5
2022-06-09 16:01:11.00368579
>>> length []
0
2022-06-09 16:01:28.140617225
>>> sum hoge
14
2022-06-09 16:01:40.974374886
>>> prpduct hoge

<interactive>:72:1: error:
    • Variable not in scope: prpduct :: [Int] -> t
    • Perhaps you meant ‘product’ (imported from Prelude)
2022-06-09 16:02:00.52094637
>>> product hoge
60
2022-06-09 16:02:13.021666996
>>> hoge ++ hoge
[3,1,4,1,5,3,1,4,1,5]
2022-06-09 16:02:32.968380716
>>> reverse hoge
[5,1,4,1,3]
2022-06-09 16:02:50.147143893
>>> product hoge
60
2022-06-09 16:03:14.743375589
>>> [1,2,3,4,5] ++ [1,2,3]
[1,2,3,4,5,1,2,3]
2022-06-09 16:04:33.968094436
>>> hoge ++ hoge
[3,1,4,1,5,3,1,4,1,5]
2022-06-09 16:04:41.487373969
>>> reverse hoge
[5,1,4,1,3]
2022-06-09 16:05:28.778704715
>>> double 3 + 3

<interactive>:80:1: error: Variable not in scope: double :: t0 -> a
2022-06-09 16:07:00.424423029
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  lenth
Ok, no modules loaded.
2022-06-09 16:07:40.497929899
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:5:1: error:
    Parse error: module header, import declaration
    or top-level declaration expected.
  |
5 | lenth
  | ^^^^^
Failed, no modules loaded.
2022-06-09 16:07:40.540631927
>>> double 3 + 3

<interactive>:83:1: error: Variable not in scope: double :: t0 -> a
2022-06-09 16:07:53.263743907
>>> double 3 + 3

<interactive>:84:1: error: Variable not in scope: double :: t0 -> a
2022-06-09 16:08:07.877148945
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  lenth
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:5:1: error:
    Parse error: module header, import declaration
    or top-level declaration expected.
  |
5 | lenth
  | ^^^^^
Failed, no modules loaded.
2022-06-09 16:09:01.712529714
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:5:1: error:
    Parse error: module header, import declaration
    or top-level declaration expected.
  |
5 | lenth
  | ^^^^^
Failed, no modules loaded.
2022-06-09 16:09:01.807909066
>>> double 3 + 3

<interactive>:87:1: error: Variable not in scope: double :: t0 -> a
2022-06-09 16:09:21.996929236
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:10:16.70541329
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:10:16.789285586
>>> bouble 3 + 3

<interactive>:90:1: error:
    • Variable not in scope: bouble :: t0 -> a
    • Perhaps you meant ‘double’ (line 4)
2022-06-09 16:10:27.408193386
>>> double 3 + 3
9
2022-06-09 16:10:37.109870435
>>> (double 3) + 3
9
2022-06-09 16:10:59.490362187
>>> double (3 + 3)
12
2022-06-09 16:11:12.635715266
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:14:22.577425178
>>> quadruple 2
8
2022-06-09 16:14:46.316911285
>>> quadruple (2 + 3)
20
2022-06-09 16:15:05.302082117
>>> :quit
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/sayuri/bprog2022/.ghci
2022-06-16 15:01:40.191057722
>>> take 3 [3,1,4,1,5]
[3,1,4]
2022-06-16 15:04:21.479465017
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
Ok, no modules loaded.
2022-06-16 15:10:47.056313826
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:10:47.122178853
>>> 
2022-06-16 15:11:39.54075781
>>> double

<interactive>:5:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-16 15:12:10.092092554
>>> take (double 2) [1,2,3,4,5]
[1,2,3,4]
2022-06-16 15:15:13.483801756
>>> [1 .. 10]
[1,2,3,4,5,6,7,8,9,10]
2022-06-16 15:19:58.064586473
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: integer -> integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:10:15: error:
    • No instance for (Num integer) arising from a use of ‘product’
      Possible fix:
        add (Num integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |               ^^^^^^^^^^^^^^^^

src/First.hs:10:23: error:
    • No instance for (Enum integer)
        arising from the arithmetic sequence ‘1 .. n’
      Possible fix:
        add (Enum integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the first argument of ‘product’, namely ‘[1 .. n]’
      In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |                       ^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:21:01.362601159
>>> fac

<interactive>:9:1: error: Variable not in scope: fac
2022-06-16 15:21:56.644929913
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: integer -> integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:10:15: error:
    • No instance for (Num integer) arising from a use of ‘product’
      Possible fix:
        add (Num integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |               ^^^^^^^^^^^^^^^^

src/First.hs:10:23: error:
    • No instance for (Enum integer)
        arising from the arithmetic sequence ‘1 .. n’
      Possible fix:
        add (Enum integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the first argument of ‘product’, namely ‘[1 .. n]’
      In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |                       ^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:22:00.151926825
>>> factorial 3

<interactive>:11:1: error:
    Variable not in scope: factorial :: t0 -> t
2022-06-16 15:22:08.259481025
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: integer -> integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:10:15: error:
    • No instance for (Num integer) arising from a use of ‘product’
      Possible fix:
        add (Num integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |               ^^^^^^^^^^^^^^^^

src/First.hs:10:23: error:
    • No instance for (Enum integer)
        arising from the arithmetic sequence ‘1 .. n’
      Possible fix:
        add (Enum integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the first argument of ‘product’, namely ‘[1 .. n]’
      In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |                       ^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:22:57.225643888
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:24:22.227037064
>>> factorial 3
6
2022-06-16 15:24:37.947219829
>>> factorial 4
24
2022-06-16 15:24:44.746304217
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:38:24.828156795
>>> average [1,2,3,4,5]
3
2022-06-16 15:38:41.885843635
>>> :t take 3 [1,2,3,4,5]
take 3 [1,2,3,4,5] :: Num a => [a]
2022-06-16 15:49:57.12621834
>>> linit [1 .. 5]

<interactive>:19:1: error:
    • Variable not in scope: linit :: [a0] -> t
    • Perhaps you meant ‘init’ (imported from Prelude)
2022-06-16 16:07:00.331537674
>>> init [1 .. 5]
[1,2,3,4]
2022-06-16 16:07:18.288731605
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) =x : (init xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 16:14:46.508762772
>>> myinit [1 .. 5]
[1,2,3,4]
2022-06-16 16:14:59.877362971
>>> myinit []
*** Exception: src/First.hs:(19,1)-(20,28): Non-exhaustive patterns in function myinit

2022-06-16 16:15:07.604576248
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/sayuri/bprog2022/.ghci
2022-06-23 14:54:39.372720355
>>> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num NominalDiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.NominalDiffTime’
instance Num DiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.DiffTime’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
2022-06-23 14:55:12.48783918
>>> 1 -- 2
1
2022-06-23 15:06:15.213639184
>>> 1 == 2
False
2022-06-23 15:06:20.086600389
>>> 1 < 2
True
2022-06-23 15:06:26.874500185
>>> 1 < 1
False
2022-06-23 15:06:34.022972286
>>> 1 <= 2
True
2022-06-23 15:06:45.222878477
>>> 1 >= 2
False
2022-06-23 15:06:52.770054051
>>> 'a' 
'a'
2022-06-23 15:11:24.213555112
>>> 'a' < 'B'
False
2022-06-23 15:11:42.598855801
>>> 'a' < 'b'
True
2022-06-23 15:11:57.970708872
>>> '' < 'a'

<interactive>:11:1: error:
    Parser error on `''`
    Character literals may not be empty
2022-06-23 15:12:10.910913213
>>> 's' <O

<interactive>:12:6: error: Data constructor not in scope: O :: Char
2022-06-23 15:12:23.561872592
>>> 's' < 'O'
False
2022-06-23 15:12:32.91558595
>>> 'H' < 'a'
True
2022-06-23 15:12:47.564651287
>>> 'ab' < 'B'

<interactive>:15:1: error:
    • Syntax error on 'ab'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'ab'
2022-06-23 15:12:58.098085767
>>> 'ab' < 'b'

<interactive>:16:1: error:
    • Syntax error on 'ab'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'ab'
2022-06-23 15:13:12.319839599
>>> 1 /= 2
True
2022-06-23 15:15:51.675881415
>>> 1 /= 1
False
2022-06-23 15:15:58.407155615
>>> :info
syntax: ':i <thing-you-want-info-about>'
2022-06-23 15:29:35.040705345
>>> :info abs
type Num :: * -> Constraint
class Num a where
  ...
  abs :: a -> a
  ...
  	-- Defined in ‘GHC.Num’
2022-06-23 15:29:43.899427431
>>> abs

<interactive>:21:1: error:
    • No instance for (Show (Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-23 15:30:49.935754575
>>> abs (-234)
234
2022-06-23 15:34:36.817368083
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/sayuri/bprog2022/.ghci
2022-06-23 15:40:11.259797416
>>> abs 

<interactive>:1:1: error:
    • No instance for (Show (Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-23 15:59:16.726209364
>>> o

<interactive>:2:1: error: Variable not in scope: o
2022-06-23 15:59:26.588498676
>>> 
2022-06-23 15:59:26.7795749
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/sayuri/bprog2022/.ghci
2022-06-30 14:56:25.874149669
>>> [x ^ 2 | x <- [1..5] ]
[1,4,9,16,25]
2022-06-30 15:00:55.952888516
>>> map (^2) [1..5]
[1,4,9,16,25]
2022-06-30 15:04:34.440869305
>>> map (^2) [1..5

<interactive>:3:15: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-30 15:11:42.265447969
>>> [ x * 2 | x <- [1..5] ]
[2,4,6,8,10]
2022-06-30 15:12:21.107588412
>>> [ x `div` 2 | x <- [1..5]]
[0,1,1,2,2]
2022-06-30 15:13:39.878475622
>>> [ x `divMod` 2 | x <- [1..5]]
[(0,1),(1,0),(1,1),(2,0),(2,1)]
2022-06-30 15:15:33.130207645
>>> [(x,y) | x <- [1,2,3], y <- [4,5]]
[(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
2022-06-30 15:17:23.012100562
>>> [(x,y) | y <- [4,5], x <- [1,2,3]]
[(1,4),(2,4),(3,4),(1,5),(2,5),(3,5)]
2022-06-30 15:18:14.025194642
>>> [(x,y) | x <- "abc", y <- [4,5]] 
[('a',4),('a',5),('b',4),('b',5),('c',4),('c',5)]
2022-06-30 15:21:12.465374004
>>> [(x,y) | y <- [4,5], x <- "abc"] 
[('a',4),('b',4),('c',4),('a',5),('b',5),('c',5)]
2022-06-30 15:21:54.127798498
>>> [(x,y) | x <- [1,2,3,4,5], y <- [7,8,9]]
[(1,7),(1,8),(1,9),(2,7),(2,8),(2,9),(3,7),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9)]
2022-06-30 15:22:32.014008301
>>> [(x,y) | x <- [1..3], y <- [x..3]]
[(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
2022-06-30 15:23:24.332398607
>>> myconcat

<interactive>:13:1: error:
    • Variable not in scope: myconcat
    • Perhaps you meant one of these:
        ‘mconcat’ (imported from Prelude), ‘concat’ (imported from Prelude)
2022-06-30 15:26:53.751457534
>>> l src/First where

<interactive>:14:13: error: parse error on input ‘where’
2022-06-30 15:29:43.415214611
>>> l src/First.hs

<interactive>:15:7: error:
    Not in scope: ‘First.hs’
    No module named ‘First’ is imported.
2022-06-30 15:30:00.540937741
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) =x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs ]
:l src/First.hs
Ok, no modules loaded.
2022-06-30 15:30:28.559318215
>>> [1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:30:28.603406574
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) =x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs ]
Ok, one module loaded.
2022-06-30 15:39:28.315535323
>>> :g
unknown command ':g'
use :? for help.
2022-06-30 15:39:36.842046904
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) =x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs ]
Ok, one module loaded.
2022-06-30 15:39:42.416804248
>>> :l
Ok, no modules loaded.
2022-06-30 15:39:42.514831985
>>> :g src/First.hs
unknown command ':g'
use :? for help.
2022-06-30 15:40:11.693316355
>>> concat  

<interactive>:23:1: error:
    • No instance for (Show ([[a0]] -> [a0]))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-30 15:41:12.397354097
>>> concat x <- [1,2,3] y <- [3,4]]

<interactive>:24:10: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
2022-06-30 15:41:38.087559855
>>> myconcat x <- [1,2,3] y <- [3,4]]

<interactive>:25:12: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
2022-06-30 15:42:04.778712019
>>> concat :: [[1,2,3,4,5]] -> [2]

<interactive>:26:12: error:
    Illegal type: ‘[1, 2, 3, 4, 5]’
      Perhaps you intended to use DataKinds

<interactive>:26:13: error:
    Illegal type: ‘1’ Perhaps you intended to use DataKinds

<interactive>:26:15: error:
    Illegal type: ‘2’ Perhaps you intended to use DataKinds

<interactive>:26:17: error:
    Illegal type: ‘3’ Perhaps you intended to use DataKinds

<interactive>:26:19: error:
    Illegal type: ‘4’ Perhaps you intended to use DataKinds

<interactive>:26:21: error:
    Illegal type: ‘5’ Perhaps you intended to use DataKinds

<interactive>:26:29: error:
    Illegal type: ‘2’ Perhaps you intended to use DataKinds
2022-06-30 15:45:44.057094818
>>> [ 1 | _<- [1..5] ]
[1,1,1,1,1]
2022-06-30 15:47:30.205831584
>>> :e
No files to edit.
2022-06-30 15:50:01.476913882
>>> :e
No files to edit.
2022-06-30 15:50:08.3384991
>>> :l
Ok, no modules loaded.
2022-06-30 15:50:08.440691694
>>> :e
No files to edit.
2022-06-30 15:50:21.97396842
>>> ['a' ..'2']

<interactive>:32:1: warning: [-Wempty-enumerations]
    Enumeration is empty
""
2022-06-30 15:51:00.569292566
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) =x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs ]
  24  
  25  mylength :: [a] -> Int
  26  mylength xs = sum [ 1 | _ <- xs ]
Ok, no modules loaded.
2022-06-30 15:51:34.004425489
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:51:34.121099449
>>> ['あ' .. 'ん'

<interactive>:35:12: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-30 15:52:05.198001022
>>> ['あ' .. 'ん'}

<interactive>:36:12: error: parse error on input ‘}’
2022-06-30 15:52:09.060494432
>>> ['あ' .. 'ん'

<interactive>:37:12: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-30 15:52:11.171881361
>>> ['あ' .. 'ん']
"\12354\12355\12356\12357\12358\12359\12360\12361\12362\12363\12364\12365\12366\12367\12368\12369\12370\12371\12372\12373\12374\12375\12376\12377\12378\12379\12380\12381\12382\12383\12384\12385\12386\12387\12388\12389\12390\12391\12392\12393\12394\12395\12396\12397\12398\12399\12400\12401\12402\12403\12404\12405\12406\12407\12408\12409\12410\12411\12412\12413\12414\12415\12416\12417\12418\12419\12420\12421\12422\12423\12424\12425\12426\12427\12428\12429\12430\12431\12432\12433\12434\12435"
2022-06-30 15:52:16.401479627
>>> mylength ['1' ..'2']
2
2022-06-30 15:52:53.072714563
>>> putStrLn it

<interactive>:40:10: error:
    • Couldn't match type ‘Int’ with ‘[Char]’
      Expected: String
        Actual: Int
    • In the first argument of ‘putStrLn’, namely ‘it’
      In the expression: putStrLn it
      In an equation for ‘it’: it = putStrLn it
2022-06-30 15:53:22.372001558
>>> putStrLn it

<interactive>:41:10: error:
    • Couldn't match type ‘Int’ with ‘[Char]’
      Expected: String
        Actual: Int
    • In the first argument of ‘putStrLn’, namely ‘it’
      In the expression: putStrLn it
      In an equation for ‘it’: it = putStrLn it
2022-06-30 15:54:14.540662195
>>> ['あ' .. 'ん']
"\12354\12355\12356\12357\12358\12359\12360\12361\12362\12363\12364\12365\12366\12367\12368\12369\12370\12371\12372\12373\12374\12375\12376\12377\12378\12379\12380\12381\12382\12383\12384\12385\12386\12387\12388\12389\12390\12391\12392\12393\12394\12395\12396\12397\12398\12399\12400\12401\12402\12403\12404\12405\12406\12407\12408\12409\12410\12411\12412\12413\12414\12415\12416\12417\12418\12419\12420\12421\12422\12423\12424\12425\12426\12427\12428\12429\12430\12431\12432\12433\12434\12435"
2022-06-30 15:54:30.342812613
>>> putStrLn it
あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをん
2022-06-30 15:54:34.167074114
>>> mylength ['a' .. 'z']
26
2022-06-30 15:55:36.477911369
>>>  ['a' .. 'z']
"abcdefghijklmnopqrstuvwxyz"
2022-06-30 15:55:55.764595507
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/sayuri/bprog2022/.ghci
2022-07-07 16:05:00.585210288
>>> :e src/Caesar where
catn: src/Caesar: openFile: does not exist (No such file or directory)
2022-07-07 16:05:25.330628896
>>> :l src/Caesar where
target ‘where’ is not a module name or a source file
2022-07-07 16:05:25.399698286
>>> :e src/Caesar where
catn: src/Caesar: openFile: does not exist (No such file or directory)
2022-07-07 16:06:10.998745802
>>> :l src/Caesar where
target ‘where’ is not a module name or a source file
2022-07-07 16:06:11.096653091
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
Ok, no modules loaded.
2022-07-07 16:06:54.320742097
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 16:06:54.43156745
>>> ord '1'
49
2022-07-07 16:07:19.459013607
>>> ord 'A'
65
2022-07-07 16:07:41.436874896
>>> ord 'a'
97
2022-07-07 16:07:47.342679601
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/sayuri/bprog2022/.ghci
2022-07-14 15:11:21.807235836
>>> :e src/Caesar where
catn: src/Caesar: openFile: does not exist (No such file or directory)
2022-07-14 15:11:43.088337853
>>> :l src/Caesar where
target ‘where’ is not a module name or a source file
2022-07-14 15:11:43.155799883
>>> let2int 'a'

<interactive>:3:1: error:
    Variable not in scope: let2int :: Char -> t
2022-07-14 15:12:43.564545237
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c
Ok, no modules loaded.
2022-07-14 15:13:12.411737251
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:13:12.497644822
>>> let2int 'a'
97
2022-07-14 15:13:26.633459715
>>> let2int '2'
50
2022-07-14 15:13:36.550119932
>>> let2int 'z'
122
2022-07-14 15:13:56.137866767
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:15:11.635204164
>>> let2int 'a'
0
2022-07-14 15:15:33.115772798
>>> let2int 'z'
25
2022-07-14 15:15:46.281971301
>>> ord 'a'
97
2022-07-14 15:19:11.314891669
>>> chr 97
'a'
2022-07-14 15:19:18.032019347
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:20:09.246261513
>>> int2let 0
'a'
2022-07-14 15:20:17.283107564
>>> int2let 25
'z'
2022-07-14 15:20:24.255642002
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:27:37.271804072
>>> shift 3 'a'
'd'
2022-07-14 15:28:01.037377647
>>> shift (-3) 'd'
'a'
2022-07-14 15:28:18.32358729
>>> shift 3 'z'
'c'
2022-07-14 15:29:10.60995027
>>> shift 3 ' '
' '
2022-07-14 15:32:54.083978126
>>> shift 3 'h'
'k'
2022-07-14 15:33:48.06009449
>>> shift 2 's'
'u'
2022-07-14 15:33:58.194194798
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16      encode :: Int -> (String -> String)
  17      encode n xs = [ shift n x | x <- xs]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:17: error: parse error on input ‘=’
   |
17 |     encode n xs = [ shift n x | x <- xs]
   |                 ^
Failed, no modules loaded.
2022-07-14 15:35:40.378256115
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16      encode :: Int -> (String -> String)
  17      encode n xs = [ shift n x | x <- xs]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:17: error: parse error on input ‘=’
   |
17 |     encode n xs = [ shift n x | x <- xs]
   |                 ^
Failed, no modules loaded.
2022-07-14 15:36:33.500642112
>>> :
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16      encode :: Int -> (String -> String)
  17      encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:17: error: parse error on input ‘=’
   |
17 |     encode n xs = [ shift n x | x <- xs ]
   |                 ^
Failed, no modules loaded.
2022-07-14 15:37:14.179838431
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16      encode :: Int -> (String -> String)
  17      encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:17: error: parse error on input ‘=’
   |
17 |     encode n xs = [ shift n x | x <- xs ]
   |                 ^
Failed, no modules loaded.
2022-07-14 15:38:00.592214979
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16      encode :: Int -> (String -> String)
  17      encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:17: error: parse error on input ‘=’
   |
17 |     encode n xs = [ shift n x | x <- xs ]
   |                 ^
Failed, no modules loaded.
2022-07-14 15:38:02.215870765
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16      encode :: Int -> (String -> String)
  17      encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:17: error: parse error on input ‘=’
   |
17 |     encode n xs = [ shift n x | x <- xs ]
   |                 ^
Failed, no modules loaded.
2022-07-14 15:38:03.010158221
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16      encode :: Int -> (String -> String)
  17      encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:17: error: parse error on input ‘=’
   |
17 |     encode n xs = [ shift n x | x <- xs ]
   |                 ^
Failed, no modules loaded.
2022-07-14 15:38:03.747239133
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:38:36.081571306
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:39:21.689045908
>>> encode 3 "haskell i fun"
"kdvnhoo l ixq"
2022-07-14 15:47:57.468653779
>>> it
"kdvnhoo l ixq"
2022-07-14 15:48:18.863924433
>>> encode (-3 ) it
"haskell i fun"
2022-07-14 15:48:55.602771734
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:58:49.678700845
>>> langth

<interactive>:37:1: error:
    • Variable not in scope: langth
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-07-14 15:59:33.221168035
>>> length

<interactive>:38:1: error:
    • No instance for (Show ([a0] -> Int))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-07-14 15:59:44.05129627
>>> length

<interactive>:39:1: error:
    • No instance for (Show ([a0] -> Int))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-07-14 15:59:53.562643417
>>> length table
26
2022-07-14 16:00:06.679064904
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = n / m * 100
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:26:15: error:
    • Couldn't match expected type ‘Float’ with actual type ‘Int’
    • In the expression: n / m * 100
      In an equation for ‘percent’: percent n m = n / m * 100
   |
26 | percent n m = n / m * 100
   |               ^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 16:06:48.645016925
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = ( fromIntegral n / fromIntegral m ) * 100
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:08:52.291348516
>>> percent 5 15
33.333336
2022-07-14 16:09:10.257723754
>>> percent 3 9
33.333336
2022-07-14 16:09:19.231131885
>>> percent 2 4
50.0
2022-07-14 16:09:26.400415902
>>> percent 3 18
16.666668
2022-07-14 16:09:51.016720082
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = ( fromIntegral n / fromIntegral m ) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x' ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:14:03.165783672
>>> count 's'

<interactive>:48:1: error:
    • No instance for (Show (String -> Int))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-07-14 16:14:36.153746649
>>> count 's' "Mississippi"
4
2022-07-14 16:15:06.393752564
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/sayuri/bprog2022/.ghci
2022-07-21 15:06:18.384654504
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = ( fromIntegral n / fromIntegral m ) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x' ]
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
Ok, no modules loaded.
2022-07-21 15:06:49.74849288
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:06:49.91695067
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = ( fromIntegral n / fromIntegral m ) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x' ]
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:19:57.255455484
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:19:57.350936291
>>> length sample
15
2022-07-21 15:20:11.435106123
>>> sample
"abbcccddddeeeee"
2022-07-21 15:20:16.519120929
>>> freqs sample
[6.666667,13.333334,20.0,26.666668,33.333336,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
2022-07-21 15:20:29.273167938
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = ( fromIntegral n / fromIntegral m ) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x' ]
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:39:01.138042008
>>> rotate

<interactive>:9:1: error:
    • No instance for (Show (Int -> [a0] -> [a0]))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-07-21 15:39:23.223163174
>>> rptate 3[1,2,3,4,5]

<interactive>:10:1: error:
    • Variable not in scope: rptate :: t0 -> [a0] -> t
    • Perhaps you meant ‘rotate’ (line 43)
2022-07-21 15:39:49.931887232
>>> rotate 3 [1,2,3,4,5]
[4,5,1,2,3]
2022-07-21 15:40:02.87109367
>>> table'

<interactive>:12:1: error:
    • Variable not in scope: table'
    • Perhaps you meant ‘table’ (line 20)
2022-07-21 15:46:25.826144626
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = ( fromIntegral n / fromIntegral m ) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x' ]
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs "kdvnhoo lv ixq"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:46:32.022981134
>>> table'
[0.0,0.0,0.0,7.1428576,0.0,0.0,0.0,7.1428576,7.1428576,0.0,7.1428576,7.1428576,0.0,7.1428576,14.285715,0.0,7.1428576,0.0,0.0,0.0,0.0,14.285715,0.0,7.1428576,0.0,0.0]
2022-07-21 15:46:40.798022368
>>> [chisqr (rotate n table') table | n <- [0 .. 25]

<interactive>:15:49: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-07-21 15:47:54.866593317
>>> [chisqr (rotate n table') table | n <- [0 .. 25]]
[1037.1161,472.26096,451.96503,150.75772,1059.9601,3122.5193,480.326,857.7907,716.2974,731.72504,367.52783,1095.8976,1689.1488,1036.0608,1097.8545,2231.09,486.6004,2085.8784,725.49756,596.9133,964.8147,627.002,2138.5535,703.25635,3905.8936,462.25485]
2022-07-21 15:48:56.057315893
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = ( fromIntegral n / fromIntegral m ) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x' ]
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chitab)chitab)
  55          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:54:24: error:
    Variable not in scope: positions :: Float -> [Float] -> [a]
   |
54 |         factor = head (positions (minimum chitab)chitab)
   |                        ^^^^^^^^^
Failed, no modules loaded.
2022-07-21 15:55:15.826957228
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = ( fromIntegral n / fromIntegral m ) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x' ]
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chitab)chitab)
  55          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
  57  
  58  positions :: Eq a => a -> [a] -> [Int]
  59  positions x xs = [ i | (x', i) <- zip xs [0 ..]]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:58:10.074503278
>>> positions False [True, False, True, False]
[0,1,2,3]
2022-07-21 15:59:29.719448106
>>> positions False [True, False, True, False]
[0,1,2,3]
2022-07-21 15:59:59.108120103
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr ( ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n)`mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = ( fromIntegral n / fromIntegral m ) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x' ]
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chitab)chitab)
  55          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
  57  
  58  positions :: Eq a => a -> [a] -> [Int]
  59  positions x xs = [ i | (x', i) <- zip xs [0 ..], x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 16:02:01.21547841
>>> positions False [True, False, True, False]
[1,3]
2022-07-21 16:02:04.278979442
>>> crack sampleAngou
"haskell is fun"
2022-07-21 16:03:32.70220494
>>> crack "vscd myzboroxcsyxc kbo ecopev"
"list coprehensions are useful"
2022-07-21 16:05:21.170981503
>>> :q
Leaving GHCi.
